#!/usr/bin/env node
/*!
 * gen-from 0.0.8
 * https://github.com/phucbm/gen-from#readme
 *
 * @license MIT
 * @author: phucbm, https://github.com/phucbm
 */
import g from"prompts";import r from"chalk";import c from"fs-extra";import p from"path";import{fileURLToPath as w}from"url";import y from"tiged";var E=w(import.meta.url),d=p.dirname(E);async function P(){let n=await c.readJson(p.join(d,"..","package.json"));console.log(r.cyan(`\u{1F680} Welcome to gen-from v${n.version}!`)),console.log(r.dim(`${n.description}
`));try{let e=process.argv.slice(2);(e.includes("--version")||e.includes("-v"))&&(console.log(n.version),process.exit(0));let s=e[0],t=e.includes("--here"),o=await $(),a=await A(o.templates,s);a||(console.log(r.red("\u274C Template selection cancelled")),process.exit(1)),console.log(r.dim(`Checking template: ${a.repo}...`)),await R(a.repo);let i=await N(o.placeholders);i||(console.log(r.red("\u274C Setup cancelled")),process.exit(1));let l=await k(i.USERNAME,i.PROJECT_NAME);l||(console.log(r.red("\u274C Setup cancelled")),process.exit(1)),i.PACKAGE_NAME=l;let f=t?".":i.PROJECT_NAME;!t&&await c.pathExists(f)?await u(f)||(console.log(r.yellow("\u274C Operation cancelled")),process.exit(0)):t&&await v(".")&&(await u(".",!0)||(console.log(r.yellow("\u274C Operation cancelled")),process.exit(0))),await T(a.repo,f),await M(f,i),console.log(r.green("\u2705 Project generated successfully!")),console.log(`
${r.yellow("Next steps:")}`),t||console.log(`  cd ${i.PROJECT_NAME}`),console.log("  pnpm install"),console.log("  pnpm build"),console.log(`  pnpm test
`)}catch(e){console.error(r.red("\u274C Error:"),e instanceof Error?e.message:e),process.exit(1)}}async function $(){let n=p.join(d,"..","templates.json"),e=p.join(d,"..","placeholders.json");if(!await c.pathExists(n))throw new Error("Templates configuration file not found");if(!await c.pathExists(e))throw new Error("Placeholders configuration file not found");let s=await c.readJson(n),t=await c.readJson(e);return{templates:s,placeholders:t}}async function A(n,e){if(e){let o;e.includes("/")?o=e:o=`phucbm/${e}`;let a=n.find(i=>i.name===e||i.repo===e||i.repo===o);return a||{name:e,description:`Template from ${o}`,repo:o}}console.log(r.yellow("Available templates:"));let s=n.map(o=>({title:`${o.name} - ${r.dim(o.description)}`,value:o}));return(await g({type:"select",name:"template",message:"Select a template:",choices:s,initial:0})).template||null}async function R(n){let e=await fetch(`https://api.github.com/repos/${n}`);if(!e.ok)throw e.status===404?new Error(`Template repository "${n}" not found on GitHub`):new Error(`Failed to verify template repository: ${e.statusText}`)}async function N(n){console.log(r.yellow(`
Provide project information:`));let e=n.map(t=>({type:"text",name:t.key,message:t.prompt,initial:t.default,validate:o=>t.required&&!o.trim()?`${t.key} is required`:!0})),s=await g(e);for(let t of n)if(t.required&&s[t.key]===void 0)return null;return s}async function k(n,e){let t=[e,`@${n}/${e}`,"Use different name"].map((a,i)=>({title:i===2?r.dim(a):a,value:a})),o=await g({type:"select",name:"packageName",message:"Choose package name:",choices:t,initial:1});return o.packageName?o.packageName==="Use different name"?(await g({type:"text",name:"customPackageName",message:"Enter package name:",initial:`@${n}/${e}`,validate:i=>i.trim()?!0:"Package name is required"})).customPackageName||null:o.packageName:null}async function T(n,e){console.log(r.dim(`
Downloading template from ${n}...`));let s=y(n,{cache:!1,force:!0,verbose:!1});try{await s.clone(e),console.log(r.green("\u2713 Template downloaded"))}catch(t){throw new Error(`Failed to download template: ${t instanceof Error?t.message:t}`)}}async function M(n,e){console.log(r.dim(`
Processing template files...`));let s=await b(n),t={};for(let[i,l]of Object.entries(e))t[i]={count:0,replacement:l};for(let i of s)if(!h(i))try{let l=await c.readFile(i,"utf-8");for(let f of Object.keys(e)){let m=l.match(new RegExp(f.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"g"));m&&(t[f].count+=m.length)}}catch{}console.log(r.yellow(`
Placeholder replacement summary:`));let o=!1;for(let[i,l]of Object.entries(t))l.count>0&&(console.log(r.cyan(`  ${i}`)+r.dim(` => Found ${l.count} occurrence${l.count===1?"":"s"} => Replacing with `)+r.green(`"${l.replacement}"`)),o=!0);o||console.log(r.dim("  No placeholders found in template files")),console.log("");let a=0;for(let i of s)await C(i,e)&&a++;o&&a>0?console.log(r.green(`\u2713 ${a} file${a===1?"":"s"} processed`)):console.log(r.green("\u2713 Template files copied"))}async function b(n){let e=[];async function s(t){let o=await c.readdir(t);for(let a of o){let i=p.join(t,a);(await c.stat(i)).isDirectory()?a!=="node_modules"&&a!==".git"&&await s(i):e.push(i)}}return await s(n),e}async function C(n,e){try{if(h(n))return!1;let s=await c.readFile(n,"utf-8"),t=!1;if(p.basename(n)==="package.json")try{let o=JSON.parse(s);if(e.PACKAGE_NAME&&(o.name=e.PACKAGE_NAME,t=!0),o.author&&typeof o.author=="object"?(e.AUTHOR_NAME&&o.author.name&&(o.author.name=e.AUTHOR_NAME,t=!0),e.USERNAME&&o.author.url&&(o.author.url=`https://github.com/${e.USERNAME}`,t=!0)):o.author&&typeof o.author=="string"&&e.AUTHOR_NAME&&(o.author=e.AUTHOR_NAME,t=!0),o.repository&&e.USERNAME&&e.PROJECT_NAME&&(typeof o.repository=="string"?(o.repository=`https://github.com/${e.USERNAME}/${e.PROJECT_NAME}`,t=!0):o.repository.url&&(o.repository.url=`https://github.com/${e.USERNAME}/${e.PROJECT_NAME}`,t=!0)),o.bugs&&e.USERNAME&&e.PROJECT_NAME&&(typeof o.bugs=="string"?(o.bugs=`https://github.com/${e.USERNAME}/${e.PROJECT_NAME}/issues`,t=!0):o.bugs.url&&(o.bugs.url=`https://github.com/${e.USERNAME}/${e.PROJECT_NAME}/issues`,t=!0)),o.homepage&&e.USERNAME&&e.PROJECT_NAME&&(o.homepage=`https://github.com/${e.USERNAME}/${e.PROJECT_NAME}`,t=!0),o.keywords&&Array.isArray(o.keywords)&&e.PROJECT_NAME){let a=["typescript","javascript",e.PROJECT_NAME.toLowerCase(),"utility"];o.keywords=[...new Set([...o.keywords,...a])],t=!0}t&&(s=JSON.stringify(o,null,2))}catch{console.warn(r.yellow("\u26A0 Warning: Could not parse package.json, using string replacement"))}for(let[o,a]of Object.entries(e))s.includes(o)&&(s=s.replace(new RegExp(o.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"g"),a),t=!0);return t&&await c.writeFile(n,s,"utf-8"),t}catch(s){return console.warn(r.yellow(`\u26A0 Warning: Could not process file ${n}: ${s}`)),!1}}function h(n){let e=[".png",".jpg",".jpeg",".gif",".ico",".svg",".pdf",".zip",".tar",".gz",".7z",".exe",".dll",".so",".dylib",".woff",".woff2",".ttf",".otf"],s=p.extname(n).toLowerCase();return e.includes(s)}async function u(n,e=!1){let s=e?"Current directory contains files. This will overwrite existing files. Continue?":`Directory "${n}" already exists. This will overwrite existing files. Continue?`;return(await g({type:"confirm",name:"replace",message:s,initial:!1})).replace||!1}async function v(n){try{return(await c.readdir(n)).filter(t=>!t.startsWith(".")&&t!=="node_modules"&&t!=="package-lock.json"&&t!=="yarn.lock"&&t!=="pnpm-lock.yaml").length>0}catch{return!1}}P().catch(console.error);export{N as collectInputs,v as hasExistingFiles,$ as loadConfig,C as processFile,A as selectTemplate,k as suggestPackageName,R as validateTemplate};
